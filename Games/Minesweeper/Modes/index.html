<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beginner's Bliss</title>
    <style>
        /* (Your CSS remains unchanged) */
    </style>
</head>
<body>
<button class="back-button" onclick="window.history.back()">‚Üê</button>

    <h1 id="gameTitle">Beginner's Bliss</h1>
    <div id="gameInfo"></div>
    <div id="minesLeft">Mines Left: <span id="minesCount">10</span></div>
    <div class="board-container">
        <div class="board" id="board"></div>
    </div>
    <button id="resetBtn">Reset Game</button>
    <div id="toast" class="toast">Congratulations! You win!</div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode');
        const name = urlParams.get('name');
        const size = parseInt(urlParams.get('size'), 10);
        const mines = parseInt(urlParams.get('mines'), 10);
        const minePercentage = parseFloat(urlParams.get('minePercentage'));

        // Set the page title and header based on the parameters
        document.title = `${name} - Minesweeper`;
        document.getElementById('gameTitle').innerText = `${name} - Minesweeper`;

        // Update the game information based on the parameters
        document.getElementById('gameInfo').innerText = `Size: ${size}x${size} | Mines: ${mines} | Mine Percentage: ${minePercentage.toFixed(2)}%`;

        let board = [];
        let revealedCount = 0;
        let minesLeft = mines;
        let firstClick = true;

        function createBoard() {
            board = Array.from({ length: size }, () => 
                Array.from({ length: size }, () => ({ 
                    state: false, revealed: false, mine: false, marked: false, value: 0 
                }))
            );
            renderBoard();
        }

        function placeMines(excludeX, excludeY) {
            let minesPlaced = 0;
            while (minesPlaced < mines) {
                const x = Math.floor(Math.random() * size);
                const y = Math.floor(Math.random() * size);
                if (!board[x][y].mine && (x !== excludeX || y !== excludeY) && 
                    !areAdjacentCellsMined(x, y, excludeX, excludeY)) {
                    board[x][y].mine = true;
                    minesPlaced++;
                }
            }
        }

        function areAdjacentCellsMined(x, y, excludeX, excludeY) {
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newX = x + i;
                    const newY = y + j;
                    if (newX === excludeX && newY === excludeY) continue;
                    if (newX >= 0 && newX < size && newY >= 0 && newY < size && board[newX][newY].mine) {
                        return true;
                    }
                }
            }
            return false;
        }

        function calculateValues() {
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (board[x][y].mine) {
                        board[x][y].value = -1;
                        continue;
                    }
                    board[x][y].value = countAdjacentMines(x, y);
                }
            }
        }

        function countAdjacentMines(x, y) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newX = x + i;
                    const newY = y + j;
                    if (newX >= 0 && newX < size && newY >= 0 && newY < size && board[newX][newY].mine) {
                        count++;
                    }
                }
            }
            return count;
        }

        function renderBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            board.forEach((row, x) => {
                row.forEach((cell, y) => {
                    const cellElement = document.createElement('div');
                    cellElement.className = 'cell';
                    cellElement.dataset.x = x;
                    cellElement.dataset.y = y;
                    cellElement.addEventListener('click', () => handleCellClick(x, y));

                    if (cell.revealed) {
                        cellElement.classList.add('revealed');
                        if (cell.mine) {
                            cellElement.classList.add('mine');
                            cellElement.innerText = 'üí£';
                        } else {
                            cellElement.innerText = cell.value > 0 ? cell.value : '';
                        }
                    }
                    if (cell.marked) {
                        cellElement.classList.add('marked');
                        cellElement.innerText = 'üö©';
                    }
                    boardElement.appendChild(cellElement);
                });
            });
        }

        function handleCellClick(x, y) {
            if (firstClick) {
                placeMines(x, y);
                calculateValues();
                firstClick = false;
            }

            const cell = board[x][y];
            if (cell.marked) {
                cell.marked = false;
                minesLeft++;
                document.getElementById('minesCount').innerText = minesLeft;
                renderBoard();
                return;
            }

            if (cell.revealed) {
                if (cell.value > 0) {
                    const markedCount = countMarkedNeighbors(x, y);
                    if (markedCount === cell.value) {
                        revealSurroundingCells(x, y);
                    }
                }
                return;
            }

            cell.revealed = true;
            revealedCount++;

            if (cell.mine) {
                showToast('Game Over! You hit a mine!');
                revealAllMines();
                renderBoard();
                setTimeout(() => {
                    resetGame();
                }, 500);
                return;
            }

            if (cell.value === 0) {
                revealAdjacentCells(x, y);
            }

            renderBoard();
            checkWinCondition();
        }

        function countMarkedNeighbors(x, y) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newX = x + i;
                    const newY = y + j;
                    if (newX >= 0 && newX < size && newY >= 0 && newY < size && board[newX][newY].marked) {
                        count++;
                    }
                }
            }
            return count;
        }

        function revealSurroundingCells(x, y) {
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const newX = x + i;
                    const newY = y + j;
                    if (newX >= 0 && newX < size && newY >= 0 && newY < size) {
                        const neighbor = board[newX][newY];
                        if (!neighbor.revealed && !neighbor.marked) {
                            neighbor.revealed = true;
                            revealedCount++;
                            if (neighbor.value === 0) {
                                revealAdjacentCells(newX, newY);
                            }
                        }
                    }
                }
            }
            renderBoard();
            checkWinCondition();
        }

        function revealAdjacentCells(x, y) {
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const newX = x + i;
                    const newY = y + j;
                    if (newX >= 0 && newX < size && newY >= 0 && newY < size) {
                        const neighbor = board[newX][newY];
                        if (!neighbor.revealed) {
                            neighbor.revealed = true;
                            revealedCount++;
                            if (neighbor.value === 0) {
                                revealAdjacentCells(newX, newY);
                            }
                        }
                    }
                }
            }
            renderBoard();
        }

        function revealAllMines() {
            board.forEach(row => {
                row.forEach(cell => {
                    if (cell.mine) {
                        cell.revealed = true;
                    }
                });
            });
            renderBoard();
        }

        function checkWinCondition() {
            if (revealedCount === size * size - mines) {
                showToast('Congratulations! You win!');
            }
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.innerText = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        document.getElementById('resetBtn').addEventListener('click', () => {
            resetGame();
        });

        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const x = e.target.dataset.x;
            const y = e.target.dataset.y;
            if (x !== undefined && y !== undefined) {
                handleRightClick(parseInt(x), parseInt(y));
            }
        });

        function handleRightClick(x, y) {
            const cell = board[x][y];
            if (cell.revealed) return;
            if (cell.marked) {
                cell.marked = false;
                minesLeft++;
            } else {
                cell.marked = true;
                minesLeft--;
            }
            document.getElementById('minesCount').innerText = minesLeft;
            renderBoard();
        }

        function resetGame() {
            firstClick = true;
            revealedCount = 0;
            minesLeft = mines;
            document.getElementById('minesCount').innerText = minesLeft;
            createBoard();
        }

        createBoard();
    </script>
</body>
</html>
